@startuml
!theme cerulean-outline
title Option -C (Smart Fragment Filtering) - Flow Diagram

start
:Input Image;

:Convert to Grayscale;
note right: cvtColor(_img, _imgGray, COLOR_BGR2GRAY)

if (Perspective Correction available?) then (yes)
  :Apply Perspective Correction;
  note right: correctPerspective() using homography
else (no)
endif

:Initial Rotation;
note right: rotate(_config.getRotationDegrees())

:Detect and Correct Skew;
note right: detectSkew() and rotate(skew_deg)

:=== DIGIT DETECTION PHASE ===;

:Generate Canny Edges;
note right: cannyEdges() with thresholds

:Find All Contours;
note right: cv::findContours(RETR_EXTERNAL)

:Filter Contours by Size;
note right
**Configurable Parameters:**
• digitMinWidth: **5** pixels
• perspectiveHeightTolerance: **1.3**
• digitMinHeight/MaxHeight
end note

:Extract Bounding Boxes;

if (Sufficient digits found?) then (no)
  stop
else (yes)
endif

:=== SMART FRAGMENT FILTERING ===;

:Analyze Digit Spacing;
note right
Calculate average spacing between digits
Check regularity with **smartSpacingTolerance: 0.5**
end note

:Analyze Digit Sizes;
note right
Calculate average width/height
Check uniformity with **smartSizeTolerance: 0.3**
end note

if (Regular spacing AND similar sizes?) then (yes)
  :Enable Smart Processing;
  :Predict 7th Digit Position (AOI);
  note right: Use average spacing for prediction
else (no)
  :Standard Processing Only;
endif

:=== DIGIT EXTRACTION PHASE ===;

partition "For each detected digit" {
  
  if (Is AOI digit?) then (yes)
    :Apply AOI Cropping;
    note right
    **AOI Parameters:**
    • cropPercentHorizontalAOI: **15%**
    • cropPercentVerticalAOI: **2%**
    end note
  else (no)
    :Apply Standard Cropping;
    note right
    **Standard Parameters:**
    • cropPercentHorizontal: **10%**
    • cropPercentVertical: **2%**
    end note
  endif

  :Extract Digit ROI;

  if (Crop Digits enabled (-C)?) then (yes)
    :=== MORPHOLOGICAL FILTERING ===;
    
    :Step 1: Calculate Kernel Size;
    note right
    kernelSize = min(width,height) / **morphKernelSizeDivisor (15)**
    Create elliptical structuring element
    end note
    
    :Step 2: Dilate Image;
    note right
    cv::dilate() with **morphIterations (1)**
    Merges nearby edges and fragments
    end note
    
    :Step 3: Find Contours in Dilated Image;
    note right: Identify all connected components
    
    if (Number of contours?) then (0 contours)
      :Return Original;
    elseif (1 contour) then (1 contour)
      :Apply Erosion Only;
      note right: Restore original thickness
    else (Multiple contours)
      :Calculate Contour Areas;
      
      :Find Largest and 2nd Largest;
      
      :Check Size Ratio;
      note right
      sizeRatio = secondMaxArea / maxArea
      Compare with **morphSizeRatioThreshold (0.4)**
      end note
      
      if (Similar sized contours?) then (yes)
        :Keep All Significant Contours;
        note right
        Handle digits with holes (0, 6, 8, 9)
        Apply erosion to all contours
        end note
      else (no)
        :Keep Only Largest Contour;
        note right
        Create mask with largest contour
        Apply mask to dilated image
        end note
      endif
      
      :Step 4: Erode Result;
      note right
      cv::erode() with **morphIterations (1)**
      Restore original edge thickness
      end note
    endif
    
    :Filtered Digit Image;
  else (no)
    :Original Digit Image;
  endif

  :Add to Digit Vector;
  
  if (Debug Mode?) then (yes)
    :Save Debug Image;
    note right
    Filename includes:
    • Crop parameters
    • Filter status (fragments_removed_smart vs none)
    end note
  else (no)
  endif
}

:All Digits Processed;

:Return Digit Vector;
note right: _digits vector with processed images

stop

@enduml